# アクターモデルを利用したアプリケーション特有の問題、一覧取得システムにおける問題のある設計、一覧取得システムを動作させる①


### 【講義】アクターモデルを利用したアプリケーション特有の問題

ここまででアクターモデルの概念について学び、
Apache Pekko の持つ耐障害性の機能も利用できるようになりました。

ただしこのアクターモデルで実用的なアプリケーションを作成しようと思った場合には、
いくつか気をつけなくてはならないポイントが存在します。

具体的にどのポイントがよく問題になるかと言えば、

- メッセージの処理速度が遅いアクターのメールボックスにメッセージが滞留して貯まるという問題
- Dead Letter という、どのメールボックスにも届かないメッセージが生まれてしまう問題

以上の 2 つが Apache Pekko を扱っていく中で起こりやすい問題となっています。

Dead Letter の対処については、
ちゃんと最後のメッセージを受け取ってからアプリケーションを終了させるように設計し、
実装するということで対処が可能です。<br>
ただし、リモートに対してメッセージを行う場合には許容しなくてはいけない場合も存在します。

この回では前者の、メールボックスにメッセージが貯まる問題をわざと引き起こし、
どのようにそのような問題を回避すればよいかを学んでいきます。<br>
メッセージが貯まるとメッセージが遅れて処理されたり、
また、メールボックスが溢れて `OutOfMemoryError` を発生させるという問題が発生します。

なおこのメッセージの滞留に関してはこれを防ぐために、
メッセージストリームという概念でバックプレッシャーを利用してメッセージングの流速を処理側からコントロールする仕組みを持つ
[Streams](https://pekko.apache.org/docs/pekko/1.1.3/stream/index.html) というツールキットも存在します。<br>
しかし今回は、この技術に関しては割愛させてもらいます。

では、具体的にどのようなアプリケーションを開発していくのかを紹介していきます。


### 【講義】一覧取得システムにおける問題のある設計</h3>

「(5文字のアルファベット).com」にあてはまるウェブサイトの一覧を作るアプリケーションを作ります。  
[aaaaa.com](https://aaaaa.com)から[zzzzz.com](https://zzzzz.com)までのウェブサイトをしらみつぶしにアクセスして、閲覧が可能なサイトはテキストファイルに、サイトドメインとさいとタイトルを書き込みます。

まずはメッセージの処理速度などを全く加味せず Pekko Actor の耐障害性の性質だけを利用して、
一覧取得システムを設計していきます。

まずは、 Main クラスでこの一覧取得システムを起動します。<br>
利用する Actor は 3 つです。

- Supervisor
- UrlsFileLoader
- UrlsListMaker

以上となります。 Supervisor は Config という設定ファイルを持ち、
UrlsFileLoader という URL のファイルの一覧を読み込むアクターと
UrlsListMaker というウェブサイトにアクセスしURLの一覧を作るアクターの親アクターとなっています。

この 3 つのアクターが協調し合いながら、一覧を作っていくことを考えます。


では、これらのアクターがどのようにメッセージングをしていくかの流れを考えてみましょう。

ここでは、

1. Main が Supervisor をスタートさせる
1. Supervisor が UrlsFileLoader に URL の読み込みをスタートさせる
1. Supervisor が URL を受け取りそれを UrlsListMaker に送りアクセスさせる
1. UrlsListMaker が Supervisor に終了を通知する
1. Supervisor が Main に終了を通知する

この流れが最も単純な流れとして考えられるでしょう。

UrlsListMaker のアクターを大量に用意しておくことによって、
並行してダウンロードができます。また Supervisor で障害のハンドリングができる構造になっており、
非常に効率の良い設計ができているように思われます。


## 【実装】一覧取得システムを動作させる

それでは、実際に動作させてみましょう。  
[こちらのリポジトリ](https://github.com/progedu/urlslistmaker-scala3)をクローンしてください。コードとデータが入っています。  
なお、アクセス対象のURLデータが入っているため、ダウンロードに多少時間がかかります。

まずはこれらのコードの内容を解説していきます。

チェックアウトしたら、 `urlslistmaker-scala3/src/main/scala/jp/co/dwango/urlslistmaker` のフォルダ内のファイルを紹介していきます。

- Config.scala
- Main.scala
- Message.scala
- Supervisor.scala
- UrlsFileLoader.scala
- WebPageLoader.scala

以上のファイル構成になっています。

Actor のメッセージに利用されるケースクラスだけを Message.scala という別ファイルにしてあります。

1 つ 1 つ解説していきましょう。まずは Config です。

<div class='code-decorate' lnum=0 fname='urlslistmaker/src/main/scala/jp/co/dwango/urlslistmaker/Config.scala'>

```scala
package jp.co.dwango.urlslistmaker

case class Config(urlsFilePath: String,
                  outputFile: String,
                  numOfPageLoader: Int)
```

</div>

<div class="detailed-code-explanation">

このアプリケーションで設定するべき項目です。<br>
「aaaaa」など .com 以外のドメイン部分の文字列を置いているファイルと、できあがった一覧のファイルの位置、そして<br>
並行ダウンロードするアクターの数が設定できるようになっています。

</div>


<div class='code-decorate' lnum=0 fname='urlslistmaker/src/main/scala/jp/co/dwango/urlslistmaker/Main.scala'>

```scala
package jp.co.dwango.urlslistmaker

import org.apache.pekko.actor.typed.ActorSystem
import scala.concurrent.Await
import scala.concurrent.duration.*

object Main:

  @main def runMain(): Unit =
    val urlsFilePath   = "./urls.txt"
    val outputFile     = "./com-sites.txt"
    val numOfPageLoader = 2000

    val config = Config(
      urlsFilePath  = urlsFilePath,
      outputFile    = outputFile,
      numOfPageLoader = numOfPageLoader
    )

    val system: ActorSystem[SupervisorMessage] =
      ActorSystem(Supervisor(config), "urls-list-maker")

    system ! Start

    Await.result(system.whenTerminated, Duration.Inf)
    println("Finished.")

```

</div>

<div class="detailed-code-explanation">

以上が Main オブジェクトです。 
各種設定をしているコードがありますが、
ここではわかりやすさのために、コード内に設定を直書きしてあります。

その後 Supervisor を親アクターとして作成して、そこに Start というメッセージを投げています。

期限なしで終了メッセージを待ち受けて、メッセージを受け付け次第 ActorSystem を終了し、
"Finished." とコンソールに出力する処理となっています。

</div>

<div class='code-decorate' lnum=0 fname='urlslistmaker/src/main/scala/jp/co/dwango/urlslistmaker/Message.scala'>

```scala
package jp.co.dwango.urlslistmaker

trait Message

sealed trait SupervisorMessage extends Message
case object Start extends SupervisorMessage
case object Finished extends SupervisorMessage
case class DownloadSuccess() extends SupervisorMessage
case class DownloadFailure() extends SupervisorMessage

sealed trait UrlsFileLoaderMessage extends Message
case object LoadUrlsFile extends UrlsFileLoaderMessage

sealed trait WebPageLoaderMessage extends Message

case class WebPageUrl(domain: String)
  extends WebPageLoaderMessage with SupervisorMessage

```

</div>

<div class="detailed-code-explanation">

Messages ではメッセージオブジェクトが定義してあります。<br>
また、利用されるアクターごとで sealed トレイトを用意し、コンパイル時警告がパターンマッチにおいて表示されるようにしています。

</div>

<div class='code-decorate' lnum=0 fname='urlslistmaker/src/main/scala/jp/co/dwango/urlslistmaker/Supervisor.scala'>

```scala
package jp.co.dwango.urlslistmaker

import org.apache.pekko
import pekko.actor.typed.scaladsl.{Behaviors, Routers}
import pekko.actor.typed.{Behavior, SupervisorStrategy}

import okhttp3.*
import java.util.concurrent.TimeUnit

object Supervisor:

  def apply(config: Config): Behavior[SupervisorMessage] =
    Behaviors.setup: ctx =>

      val client =
        OkHttpClient.Builder()
          .connectTimeout(1, TimeUnit.SECONDS)
          .writeTimeout(1, TimeUnit.SECONDS)
          .readTimeout(1, TimeUnit.SECONDS)
          .build()

      val loaderPool =
        Routers
          .pool[WebPageLoaderMessage](config.numOfPageLoader):
            Behaviors
              .supervise(
                WebPageLoader(config, client, ctx.self)
              )
              .onFailure[Exception](SupervisorStrategy.restart)
          .withRoundRobinRouting()

      val router = ctx.spawn(loaderPool, "web-page-loader-pool")

      var fileLoadedUrlCount = 0
      var successCount       = 0
      var failureCount       = 0

      def logAndCheckFinish(): Unit =
        val total = successCount + failureCount
        ctx.log.info(s"total: $total, success: $successCount, failure: $failureCount")
        if total == fileLoadedUrlCount && total > 0 then
          ctx.log.info("All URLs processed — shutting down.")
          ctx.system.terminate()

      Behaviors.receiveMessage:
        case Start =>
          val fileLoader = ctx.spawn(
            UrlsFileLoader(config, ctx.self),
            "urls-file-loader"
          )
          fileLoader ! LoadUrlsFile
          Behaviors.same

        case url @ WebPageUrl(_) =>
          fileLoadedUrlCount += 1
          router ! url
          Behaviors.same

        case DownloadSuccess() =>
          successCount += 1
          logAndCheckFinish()
          Behaviors.same

        case DownloadFailure() =>
          failureCount += 1
          logAndCheckFinish()
          Behaviors.same

        case Finished =>
          Behaviors.same

```

</div>

<div class="detailed-code-explanation">

これが Supervisor の実装です。 まず幾つかの状態を宣言しています。

- ダウンロードに成功した数を保管する successCount
- ダウンロードに失敗した数を保管する failureCount
- 読み込み終えたウェブサイトの数を保管する fileLoadedUrlCount

以上のフィールドが宣言されています。

client は、アクターで共通して利用する HTTP 通信のクライアントです。<br>
[OkHttp](http://square.github.io/okhttp/) というライブラリのものが利用されています。

この OkHttpClient は内部的にスレッドプールとコネクションプールを持つ HTTP クライアントです。
今回は非同期IOを特に用いず、この [OkHttp](http://square.github.io/okhttp/) の並行ダウンロードの仕組みをそのまま利用し、
Pekko Actor には障害のハンドリングだけをするように実装してあります。

router には、 指定されたページローダの数の Actor を作った UrlsListMaker がルータとして用意してあります。<br>
今回の設定では 2000 個利用されています。

receive メソッドの中身は、 Start を受けたあと、
まずは URL を読み込む UrlsFileLoader に LoadUrlsFile というメッセージが渡される仕組みとなっています。

</div>

<div class='code-decorate' lnum=0 fname='urlslistmaker/src/main/scala/jp/co/dwango/urlslistmaker/UrlsFileLoader.scala'>

```scala
package jp.co.dwango.urlslistmaker

import org.apache.pekko
import pekko.actor.typed.{ActorRef, Behavior}
import pekko.actor.typed.scaladsl.Behaviors

import scala.io.{Codec, Source}

object UrlsFileLoader:
  
  def apply(config: Config, supervisor: ActorRef[SupervisorMessage]): Behavior[UrlsFileLoaderMessage] =
    Behaviors.receiveMessage:

      case LoadUrlsFile =>
        val file = Source.fromFile(config.urlsFilePath)(Codec.UTF8)
        try
          for line <- file.getLines() do
            supervisor ! WebPageUrl(line)
        finally
          file.close()

        Behaviors.same

```

</div>

<div class="detailed-code-explanation">

以上は、 UrlsFileLoader のアクターの実装です。<br>
名前の通り URL をファイルから 1 つずつ読み込んでいきます。

一行読み込むごとに Supervisor へ WebPageUrl のメッセージを投げます。<br>
そして WebPageUrl には url が含まれています。

Supervisor は一度この WebPageUrl を受け取ると、
渡されてきたロードし終えた URL の数をカウントアップします。そのあと、
UrlsListMaker にこのメッセージを投げ返してダウンロードを開始させる動きをします。

</div>

そして次が、画像のダウンロードする部分の WebPageLoader アクターの実装です。

<div class='code-decorate' lnum=0 fname='urlslistmaker/src/main/scala/jp/co/dwango/urlslistmaker/WebPageLoader.scala'>

```scala
package jp.co.dwango.urlslistmaker

import org.apache.pekko
import pekko.actor.typed.{ActorRef, Behavior}
import pekko.actor.typed.scaladsl.Behaviors

import okhttp3.*

import java.io.IOException
import java.nio.charset.StandardCharsets
import java.nio.file.{Files, Paths, StandardOpenOption}
import scala.util.{Failure, Success, Try}

object WebPageLoader:

  def apply(
             config: Config,
             client: OkHttpClient,
             supervisor: ActorRef[SupervisorMessage]
           ): Behavior[WebPageLoaderMessage] =

    Behaviors.setup: context =>

      val targetPath = Paths.get(config.outputFile)
      if Files.notExists(targetPath) then Files.createFile(targetPath)

      Behaviors.receiveMessage:

        case WebPageUrl(domain) =>
          val url      = s"https://$domain.com"
          val request  = Request.Builder().url(url).build()

          client.newCall(request).enqueue(new Callback:
            override def onFailure(call: Call, e: IOException): Unit =
              supervisor ! DownloadFailure()          // 通信自体が失敗

            override def onResponse(call: Call, response: Response): Unit =
              try
                if response.isSuccessful then
                  val body       = response.body.string
                  val titleRegex = "<title>(.+?)</title>".r
                  val title      = titleRegex.findFirstMatchIn(body).map(_.group(1)).getOrElse("None")
                  val line       = s"$domain.com\t$title\n"

                  Try:
                    Files.write(
                      targetPath,
                      line.getBytes(StandardCharsets.UTF_8),
                      StandardOpenOption.APPEND
                    )
                  match
                    case Success(_) => supervisor ! DownloadSuccess()
                    case Failure(_) => supervisor ! DownloadFailure()  // 書き込み失敗
                else
                  supervisor ! DownloadFailure()      // HTTP ステータスが失敗
              finally
                response.close()
          )

          Behaviors.same

```

</div>

<div class="detailed-code-explanation">

以上が UrlsLisWebPageLoadertMaker のウェブサイトアクセス部分となります。<br>
アクセスに利用する OkHttpClient はアクターのコンストラクタで受け取ります。

サイトのアクセスに成功した場合には、 Supervisor に DownloadSuccess というメッセージを投げます。
失敗した場合には、 DownloadFailure というメッセージを投げるように実装してあります。

</div>


一旦ここまでのメッセージの流れを図にするとこのようになります。

<p class="image-with-captison">
  <img src="image/message-flow-01.png">
  <span class="imagecaption figure">メッセージの流れ</span>
</p>


以上を読み大体の構成が確認できたら、実際に動作させてみましょう。<br>
今回は、sbtシェルで起動し `run` をしてください。

なお、このアプリケーションは大量にメモリを使うため、正しく動作しない可能性があります。<br>
場合によっては**途中でメモリを使い果たし、固まるか勝手に終了**してしまいます。

固まった場合、PowerShellやターミナルを閉じても処理が続いてしまい、PC が重くなり熱くなります。その場合は `ps` コマンドなどでプロセスを強制終了しましょう。

またなんとか動いた場合には、Windowsならタスクマネージャー、macOSならアクティビティモニターを開いてJavaのプロセスが1GB以上のメモリを使っていることを確認してください。<br>
そして終了できない場合にはそこから、タスクまたはプロセスを終了させてください。

それでは、ここからなぜこのようにメモリを使い果たしてしまうのかを見ていきましょう。

## 【講義】一覧取得システムの設計の見直し

実際にこのアプリケーションのメモリの状況を、
VisualVM や jmap コマンドを利用してヒープダンプを出力してメモリの状況を見ると明らかなのですが、
現在の実装では大量のメッセージがメールボックスへ貯まる構造になっています。


原因の大きな要因としては、

- 「URLをファイルよりロードを行うスピード」は、「ページをインターネットよりダウンロードするスピード」よりも圧倒的に早い

ということがあります。

仮に 2000 個のアクターを用意していたとしてもすべてのメッセージを消化できず、
 WebPageLoader のメールボックスに大量のメッセージ溜まっていってしまうのです。

つまり 2000 並列であっても消化しきれないほどのパフォーマンスがあるということなのです。

さて、これを直すにはどうすればよいのでしょうか。

一番簡単なのは、 WebPageLoader が最も時間のかかる処理であるので、
このアクターから問い合わせを開始してダウンロードする形式にすれば良いでしょう。<br>
このようなメッセージングを**問い合わせ型のメッセージング**といいます。

今までトップダウンに命令を送っていけば良いと言う考えでしたが、これを改め、個々のアクターが仕事が終わったら次の仕事をくださいと手を挙げる方式にするといことです。

まず Supervisor は WebPageLoader に LoadWebPage というメッセージを投げます。

 そのメッセージを元に、 WebPageLoader はダウンロードしたい、
URL を 1 つだけ UrlsFileLoader に要求するのです。

そして受け取った URL を元にダウンロードした後、
自分自身にもう一度 LoadWebPage とうメッセージを投げて再度ダウンロードします。

つまり 2000 個で並列した アクターが必要になった分だけ URL をファイルから請求する構造にすることで、
メールボックスに沢山のメッセージが貯まることを防ぐことができるのです。


## 【実装】一覧取得システムの不具合修正

これを実装するとこのようになります。<br>
以下の変更差分のように実装してみましょう。

なおソースコードは、[https://github.com/progedu/urlslistmaker-scala3](https://github.com/progedu/urlslistmaker-scala3) リポジトリの、
`fix/out-of-memory` ブランチに入っているコードになります。

まず、 `Message.scala` において、
メッセージの構成に `LoadWebPage` というメッセージを追加しました。

<div class='code-decorate' lnum=4 fname='urlslistmaker/src/main/scala/jp/co/dwango/urlslistmaker/Message.scala'>

```diff-scala
sealed trait SupervisorMessage extends Message
case object Start extends SupervisorMessage
-case object Finished extends SupervisorMessage
+case object Finished extends SupervisorMessage with WebPageLoaderMessage
case class DownloadSuccess() extends SupervisorMessage
case class DownloadFailure() extends SupervisorMessage
```

</div>
<br>
<div class='code-decorate' lnum=11 fname='urlslistmaker/src/main/scala/jp/co/dwango/urlslistmaker/Message.scala'>

```diff-scala
sealed trait UrlsFileLoaderMessage extends Message
-case object LoadUrlsFile extends UrlsFileLoaderMessage
+case class LoadUrlsFile(replyTo: ActorRef[WebPageLoaderMessage]) extends UrlsFileLoaderMessage

sealed trait WebPageLoaderMessage extends Message
+case object LoadWebPage extends WebPageLoaderMessage

case class WebPageUrl(domain: String)
-  extends WebPageLoaderMessage with SupervisorMessage
+  extends WebPageLoaderMessage
```

</div>

Finished メッセージも WebPageLoader で受け取れるようになり、LoadUrlsFile では Typed Actor の特徴である型安全なメッセージングのため、replyTo パラメータを追加しています。

Main.scala は変更ありませんので、次に、 Supervisor.scala の変更を確認します。


<div class='code-decorate' lnum=15 fname='urlslistmaker/src/main/scala/jp/ed/nnn/urlslistmaker/Supervisor.scala'>

```diff-scala
      val router = ctx.spawn(loaderPool, "web-page-loader-pool")

-      var fileLoadedUrlCount = 0
+      var finishCount = 0
      var successCount       = 0
      var failureCount       = 0

-      def logAndCheckFinish(): Unit =
+      def logProgress(): Unit =
        val total = successCount + failureCount
        ctx.log.info(s"total: $total, success: $successCount, failure: $failureCount")
```
</div>
<br>
<div class='code-decorate' lnum=22 fname='urlslistmaker/src/main/scala/jp/ed/nnn/urlslistmaker/Supervisor.scala'>

```diff-scala
+      val fileLoader = ctx.spawn(
+        UrlsFileLoader(config),
+        "urls-file-loader"
+      )
+
      val loaderPool =
        Routers
          .pool[WebPageLoaderMessage](config.numOfPageLoader):
            Behaviors
              .supervise(
-                WebPageLoader(config, client, ctx.self)
+                WebPageLoader(config, client, ctx.self, fileLoader)
              )
              .onFailure[Exception](SupervisorStrategy.restart)
          .withRoundRobinRouting()
```
</div>



<div class='code-decorate' lnum=38 fname='urlslistmaker/src/main/scala/jp/ed/nnn/urlslistmaker/Supervisor.scala'>

```diff-scala 
      Behaviors.receiveMessage:
        case Start =>
-          val fileLoader = ctx.spawn(
-            UrlsFileLoader(config, ctx.self),
-            "urls-file-loader"
-          )
-          fileLoader ! LoadUrlsFile
-          Behaviors.same
-
-        case url @ WebPageUrl(_) =>
-          fileLoadedUrlCount += 1
-          router ! url
+          // すべてのWebPageLoaderにLoadWebPageメッセージを送信してスタートさせる
+          for _ <- 1 to config.numOfPageLoader do
+            router ! LoadWebPage
          Behaviors.same

        case DownloadSuccess() =>
          successCount += 1
-          logAndCheckFinish()
+          logProgress()
          Behaviors.same

        case DownloadFailure() =>
          failureCount += 1
-          logAndCheckFinish()
+          logProgress()
          Behaviors.same

        case Finished =>
+          finishCount += 1
+          if finishCount == config.numOfPageLoader then
+            ctx.log.info("All WebPageLoaders finished — shutting down.")
+            ctx.system.terminate()
          Behaviors.same
```

</div>

<div class="detailed-code-explanation">

fileLoadedUrlCount を finishCount に変更します。
ロードしたカウントの数によってではなく、終了した数がアクターの総数に達した瞬間、全体の終了を通知するよう変更しています。

Apache Pekko の Typed Actor では、Akka Classic の Broadcast は使用せず、代わりに for ループで個別にメッセージを送信します。
これにより全ての WebPageLoader を一気に動作させることができます。

</div>

次に WebPageLoader を見ていきましょう。

<div class='code-decorate' lnum=12 fname='urlslistmaker/src/main/scala/jp/co/dwango/urlslistmaker/WebPageLoader.scala'>

```diff-scala
 class WebPageLoader(config: Config,
                           client: OkHttpClient,
+                          urlsFileLoader: ActorRef
                          ) extends Actor {
```

</div>
<br>
<div class='code-decorate' lnum=22 fname='urlslistmaker/src/main/scala/jp/co/dwango/urlslistmaker/WebPageLoader.scala'>

```diff-scala
   override def receive = {
 
-    case webPageUrl: WebPageUrl => {
-      originalSender = sender()
+    case LoadWebPage => {
+      if(sender() != self) originalSender = sender()
+      urlsFileLoader ! LoadUrlsFile
+    }
 
+    case webPageUrl: WebPageUrl => {
       val url = "https://" + webPageUrl.domain + ".com"

       val request = new Request.Builder()
         .url(url)
         .build()
 
       client.newCall(request).enqueue(new Callback {
-        override def onFailure(call: Call, e: IOException): Unit = originalSender ! DownloadFailure
+        override def onFailure(call: Call, e: IOException): Unit =  {
+          originalSender ! DownloadFailure
+          downloadNext()
+        }
 
         override def onResponse(call: Call, response: Response): Unit = {
           if (response.isSuccessful) {
```

</div>
<br>
<div class='code-decorate' lnum=52 fname='urlslistmaker/src/main/scala/jp/co/dwango/urlslistmaker/WebPageLoader.scala'>

```diff-scala
             originalSender ! DownloadFailure
           }
           response.close()
+          downloadNext()
         }
       })
     }
+
+    case Finished => originalSender ! Finished
   }
 
+  private[this] def downloadNext(): Unit = self ! LoadWebPage
+
 }
```

</div>

<div class="detailed-code-explanation">

UrlsListMaker アクターでは、
LoadWebPage を受け取った後元の送り元のアクターの参照を保存し、
UrlsFileLoader に URL を請求するためのメッセージを送ります。

そして今度は UrlsFileLoader が返してきた WebPageUrl を処理して画像のダウンロードを開始するように変更しています。

また最後にアクセスが終わったら自分自身に LoadWebPage のメッセージを送り直します。<br>
これによって、1 つずつですが UrlsListMaker がひたすらアクセスするようになっています。

ただし Finished メッセージを UrlsFileLoader から受け取った場合にはそれを Supervisor に転送し、
全体の終了を促す仕組みになっています。

</div>

最後に UrlsFileLoader を見てみましょう。

<div class='code-decorate' lnum=6 fname='urlslistmaker/src/main/scala/jp/ed/nnn/urlslistmaker/UrlsFileLoader.scala'>

```diff-scala
 class UrlsFileLoader(config: Config) extends Actor {
 
+  val urlsFileSource = Source.fromFile(config.urlsFilePath)(Codec.UTF8)
+  val urlsIterator = urlsFileSource.getLines()
+
   override def receive = {
 
     case LoadUrlsFile =>
-      val urlsFileSource = Source.fromFile(config.urlsFilePath)(Codec.UTF8)
-      val urlsIterator = urlsFileSource.getLines()
-      urlsIterator.foreach((line) => {
+      if (urlsIterator.hasNext) {
+        val line = urlsIterator.next()
         val webPageUrl = WebPageUrl(line)
         sender() ! webPageUrl
-      })
-      urlsFileSource.close()
+      } else {
+        sender() ! Finished
+      }
+  }
+
+  override def postStop(): Unit =  {
+    super.postStop()
+    urlsFileSource.close()
   }
 }
```

</div>

<div class="detailed-code-explanation">

以上のようにアクターのインスタンス生成時に一度ファイルを開いておき、
LoadUrlsFile を受け取る度に、1 つの WebPageUrl を送り主に返すように動作を変更しました。

これによって、大量の WebPageUrl メッセージでメールボックスが溢れて
OutOfMemoryError が発生してしまうことを防ぐことができるわけです。

そもそも前の実装では receive メソッドの実行に非常に時間がかかる処理となっていました。<br>
メッセージが来る度、一行ずつ処理してやることによって、receive の実行時間も非常に短くなり、
何か問題があった際にはファイルの最初から URL を読み直すことができるようになっています。

そしてファイルがおわりに達したときには、送り主へ Finished メッセージを送るようになっています。

この Finished メッセージは Supervisor に転送され、
その Finished メッセージの数が UrlsListMaker のアクターの数に達した時このアプリケーション自体が終了されるようになっています。

</div>

以上を無事実装、またはチェックアウトできたら、 実際に動かしてみましょう。

問題なく大量のウェブサイトにアクセスし続けてくれるのではないでしょうか。<br>
あまりにも大量にアクセスするため、回線が混んでしまう可能性があります。ご注意ください。  
また、時折タイムアウトメッセージが出てくることがありますが、気にしなくてけっこうです。

実際に VisualVM などでこのアプリケーションのヒープの様子を確認してみましょう。<br>
するとメモリは数百 MB を維持し、また、
IO 上のトラブルが発生しても特に問題なく並列してダウンロードしてくれることを確認できるのではないかと思います。

以上が Apache Pekko Actor でアプリケーションを実装する際に気をつけなくてはならない、
メールボックスにメッセージが溢れてしまうという問題の解決でした。

なおこのメールボックスにメッセージが溢れてたり、
メッセージに遅延が生じたりしてしまうという問題は他に

- メールボックスのサイズを固定値に変更して、問題が致命的になる前に終了させる
- メッセージ送信のバックプレッシャーを制御する Apache Pekko Streams を利用する

以上 2 つの解決策もあります。<br>
実際の問題に対処する際は、これらも考慮に入れながら対応をしていくと良いでしょう。

並行処理性能や耐障害性の性能を引き出すために Apache Pekko Actor は、抽象化されて非常に便利です。

しかし逆にアクターモデルならではの、
非同期のメッセージングの問題をしっかり考慮に入れた設計を必要があるということは気をつけなくてはいけません。

## <a name="summary"></a> まとめ {.summary-h2}

<div>

- Apache Pekko Actor のメッセージングでは、場合によってはメールボックスにメッセージが貯まったり遅延が発生するということを考慮してやる必要がある
- メッセージの滞留は、メッセージを問い合わせる形式にしたり、メールボックスのサイズを制限することによって防ぐことができる
- Apache Pekko Typed Actor では、Router を使って複数のアクターに効率的にメッセージを配信することができる

</div>

## <a name="practice"></a> 挑戦 {.practice-h2}

挑戦には初級・中級・上級の課題が用意されていますので、
自分の実力に合わせて調べたりしながらチャレンジしてみてください。


### 初級


修正がされた後の urlslistmaker を
[GitHub のリポジトリ](https://github.com/progedu/urlslistmaker-scala3) の 
`fix/out-of-memory` ブランチにチェックアウトしてビルドした後、 VisualVM でどのようにメモリがたまっていくのかを観察してみましょう。

可能ならば、スレッドの状況やヒープの様子がのどのようになっているかもデバッグしてみましょう。

### 中級


修正がされる前の urlslistmaker の WebPageLoader アクターにおいて 
numOfPageLoader を 20 に設定した後、
Apache Pekko のメールボックス設定を利用してメッセージの滞留を検出するように修正してみましょう。

完成したら [GitHub のリポジトリ](https://github.com/progedu/urlslistmaker-scala3)をフォークして、
解答をプルリクエストで送ってみましょう。


### 上級


一覧取得システム urlslistmaker を [Apache Pekko Streams](https://pekko.apache.org/docs/pekko/1.1.3/stream/index.html) を利用して、
メッセージの滞留が生じないように実装してみましょう。

完成したら [GitHub のリポジトリ](https://github.com/progedu/urlslistmaker-scala3)をフォークして、
解答をプルリクエストで送ってみましょう。

なおこの問題に関しては解答例は用意しておりませんので、自力で実装してみましょう。


## <a name="practice_answer"></a> 挑戦の解答例 {.practice-h2}

<a id="show-answer-button" onclick="toggleAnswer()" class="game-book-button">解いてみたので、答えを表示する</a>

<div class="answer" >

### 初級


`Main.scala` ファイルを自分の環境に合うように修正して、

```
sbt assembly
```

以上のコマンドでビルドし、

```
sbt run
```

から一覧取得システムを起動しましょう。その後、VisualVM を起動し、 `urlslistmaker-assembly-1.0.jar` のプロセスとなっているものにアタッチして観察してみましょう。
  


### 中級

ルートディレクトリに application.conf ファイルを作成し、


```scala
pekko {
  actor {
    default-mailbox {
      mailbox-type = "org.apache.pekko.dispatch.BoundedMailbox"
      mailbox-capacity = 10
      mailbox-push-timeout-time = 10s
    }
  }
}
```


以上のように設定し、Apache Pekko Typed Actor では、メールボックスの設定は application.conf で行い、WebPageLoader の設定を以下のように変更します。
  

<div class='code-decorate' lnum=3 fname='urlslistmaker/src/main/scala/jp/co/dwango/urlslistmaker/WebPageLoader.scala'>

```diff-scala
 import java.nio.file.{Files, Paths, StandardOpenOption}

 import akka.actor.{Actor, ActorRef}
+import akka.dispatch.{BoundedMessageQueueSemantics, RequiresMessageQueue}
 import okhttp3._

 import scala.util.{Failure, Success, Try}
```

</div>
<br>
<div class='code-decorate' lnum=12 fname='urlslistmaker/src/main/scala/jp/co/dwango/urlslistmaker/WebPageLoader.scala'>

```diff-scala
 class WebPageLoader(config: Config,
                           client: OkHttpClient,
-                         ) extends Actor {
+                         ) extends Actor
+  with RequiresMessageQueue[BoundedMessageQueueSemantics] {

   var originalSender = Actor.noSender
```

</div>

また Main.scala では、

<div class='code-decorate' lnum=0 fname='urlslistmaker/src/main/scala/jp/ed/nnn/urlslistmaker/Main.scala'>

```diff-scala
 package jp.ed.nnn.urlslistmaker

+import java.io.File
+
 import akka.actor.{ActorSystem, Inbox, Props}
+import com.typesafe.config.ConfigFactory

 import scala.concurrent.Await
 import scala.concurrent.duration._
```

</div>
<br>
<div class='code-decorate' lnum=8 fname='urlslistmaker/src/main/scala/jp/ed/nnn/urlslistmaker/Main.scala'>

```diff-scala
   val urlsFilePath = "./urls.txt"
   val outputFile = "./com-sites.txt"
-  val numOfDownloader = 2000
+  val numOfDownloader = 20
   val config = Config(
     urlsFilePath,
     outputFile,
     numOfDownloader)

-  val system = ActorSystem("urlslistmaker")
+  val system = ActorSystem("urlslistmaker",
+    ConfigFactory.parseFile(new File("application.conf")))
   val inbox = Inbox.create(system)
   implicit val sender = inbox.getRef()
```

</div>

以上のようにして、 `application.conf` ファイルを読み込んで変更した設定で ActorSystem を利用するようにします。
  </p>


これで、アクターはメッセージが滞留した瞬間に終了し、Dead Letter が発生するようになります。<br>
実際には Dead Letter が発生し次第、なんらかの対処が行われるような処理を実装することとなります。
  

### 上級


この挑戦問題には解答例は存在しませんので、自力でチャレンジしてみましょう。



</div>

</div>
<!-- tweetForm -->
<h2 class="ending-h2">お疲れさまでした！</h2>
<p>学習したことをSNSで報告しよう！</p>
<p>
<a href="https://twitter.com/share?ref_src=twsrc%5Etfw"
class="twitter-share-button"
data-size="large"
data-text="#N予備校 大規模Webアプリコース 並行処理プログラミングコース 10節 
『一覧取得システムの開発』の学習が完了しました！&#13;&#10"
data-url="https://www.nnn.ed.nico/pages/programming/"
data-hashtags="プログラミング #N予備校 #N予備校大規模Webアプリコース"
data-show-count="false">Tweet</a>
<script src="https://platform.twitter.com/widgets.js" charset="utf-8" async></script>
</p>
<!-- tweetForm -->
